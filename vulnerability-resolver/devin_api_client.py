import os
import time
import requests
from typing import Dict, Any, Optional, List


class DevinAPIClient:
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.environ.get('DEVIN_API_KEY')
        if not self.api_key:
            raise ValueError("DEVIN_API_KEY not found in environment variables")
        
        self.base_url = "https://api.devin.ai/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
    
    def create_session(self, repo_url: str, prompt: str, 
                      branch: Optional[str] = None) -> Optional[str]:
        endpoint = f"{self.base_url}/sessions"
        
        payload = {
            "repo_url": repo_url,
            "prompt": prompt
        }
        
        if branch:
            payload["branch"] = branch
        
        try:
            response = requests.post(endpoint, json=payload, headers=self.headers, timeout=30)
            response.raise_for_status()
            
            data = response.json()
            session_id = data.get('session_id')
            
            if session_id:
                print(f"Created Devin session: {session_id}")
                return session_id
            else:
                print(f"Failed to create session: No session_id in response")
                return None
                
        except requests.exceptions.RequestException as e:
            print(f"Error creating Devin session: {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response: {e.response.text}")
            return None
    
    def get_session_status(self, session_id: str) -> Optional[Dict[str, Any]]:
        endpoint = f"{self.base_url}/sessions/{session_id}"
        
        try:
            response = requests.get(endpoint, headers=self.headers, timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error getting session status: {e}")
            return None
    
    def wait_for_completion(self, session_id: str, 
                           max_wait_seconds: int = 1800,
                           poll_interval: int = 30) -> Optional[Dict[str, Any]]:
        start_time = time.time()
        
        print(f"Waiting for session {session_id} to complete...")
        
        while time.time() - start_time < max_wait_seconds:
            status_data = self.get_session_status(session_id)
            
            if not status_data:
                print("Failed to get session status")
                return None
            
            status = status_data.get('status')
            print(f"Session status: {status}")
            
            print(f"Session data keys: {list(status_data.keys())}")
            for key in ['output', 'message', 'result', 'summary', 'final_output', 'messages']:
                if key in status_data:
                    value = status_data[key]
                    if isinstance(value, str):
                        snippet = value[:120].replace('\n', ' ')
                        print(f"  {key}: {snippet}... (length: {len(value)})")
                    elif isinstance(value, (list, dict)):
                        print(f"  {key}: {type(value).__name__} with {len(value)} items")
            
            pr_url = self.extract_pr_url(status_data)
            if pr_url:
                print(f"PR detected during polling: {pr_url}")
                print(f"Treating session as complete (early exit)")
                return status_data
            
            if status in ['completed', 'success', 'done', 'finished']:
                print(f"Session completed successfully")
                return status_data
            elif status in ['failed', 'error', 'cancelled', 'open_pr', 'awaiting_review', 'idle']:
                print(f"Session ended with status: {status}")
                return status_data
            
            time.sleep(poll_interval)
        
        print(f"Timeout waiting for session to complete after {max_wait_seconds}s")
        return None
    
    def extract_pr_url(self, session_data: Dict[str, Any]) -> Optional[str]:
        if not session_data:
            return None
        
        import re
        from urllib.parse import urlparse
        pr_url_pattern = r'https?://(?:www\.)?github\.com/[^/\s]+/[^/\s]+/pull/\d+(?:[^\s)]*)?'
        
        def validate_github_pr_url(url: str) -> bool:
            """Validate that URL is a legitimate GitHub PR URL"""
            if not url:
                return False
            try:
                parsed = urlparse(url)
                # Check hostname is github.com or *.github.com
                hostname = parsed.hostname
                if not hostname:
                    return False
                if hostname != 'github.com' and not hostname.endswith('.github.com'):
                    return False
                # Check path contains /pull/
                if '/pull/' not in parsed.path:
                    return False
                return True
            except Exception:
                return False
        
        pr_url = session_data.get('pr_url')
        if pr_url and validate_github_pr_url(pr_url):
            print(f"Found PR URL in 'pr_url' field: {pr_url}")
            return pr_url
        
        output = session_data.get('output', '')
        if output:
            match = re.search(pr_url_pattern, output)
            if match:
                candidate_url = match.group(0)
                if validate_github_pr_url(candidate_url):
                    print(f"Found PR URL in 'output' field: {candidate_url}")
                    return candidate_url
        
        pr_url, path = self._recursive_find_pr_url(session_data, pr_url_pattern)
        if pr_url and validate_github_pr_url(pr_url):
            print(f"Found PR URL via recursive search at path '{path}': {pr_url}")
            return pr_url
        
        return None
    
    def _recursive_find_pr_url(self, data: Any, pattern: str, path: str = "root") -> tuple[Optional[str], Optional[str]]:
        import re
        
        if isinstance(data, str):
            if 'github.com' in data and '/pull/' in data:
                match = re.search(pattern, data)
                if match:
                    return match.group(0), path
        elif isinstance(data, dict):
            for key, value in data.items():
                result_url, result_path = self._recursive_find_pr_url(value, pattern, f"{path}.{key}")
                if result_url:
                    return result_url, result_path
        elif isinstance(data, list):
            for i, item in enumerate(data):
                result_url, result_path = self._recursive_find_pr_url(item, pattern, f"{path}[{i}]")
                if result_url:
                    return result_url, result_path
        
        return None, None
    
    def create_vulnerability_fix_session(self, repo_url: str, 
                                        batch: Dict[str, Any],
                                        branch: Optional[str] = None) -> Optional[str]:
        prompt = self._build_prompt(batch, branch)
        return self.create_session(repo_url, prompt, branch)
    
    def _build_prompt(self, batch: Dict[str, Any], branch: Optional[str] = None) -> str:
        pr_title = batch.get('pr_title', 'Fix CodeQL vulnerabilities')
        vulnerabilities = batch.get('vulnerabilities', [])
        
        prompt_parts = [
            f"# Task: {pr_title}",
            "",
            "Please fix the following security vulnerabilities identified by CodeQL:",
            ""
        ]
        
        for i, vuln in enumerate(vulnerabilities, 1):
            file_path = vuln.get('file_path', 'unknown')
            line_number = vuln.get('line_number', 0)
            rule_name = vuln.get('rule_name', vuln.get('rule_id', 'unknown'))
            message = vuln.get('message', 'No description')
            severity = vuln.get('severity', 'unknown')
            
            prompt_parts.append(f"{i}. **{rule_name}** ({severity} severity)")
            prompt_parts.append(f"   - Location: `{file_path}:{line_number}`")
            prompt_parts.append(f"   - Issue: {message}")
            prompt_parts.append("")
        
        requirements = [
            "## Requirements:",
            "- Fix all listed vulnerabilities",
            "- Ensure fixes follow security best practices",
            "- Maintain existing functionality",
            "- Run any available tests to verify fixes"
        ]
        
        if branch:
            requirements.append(f"- Create a PR targeting the `{branch}` branch")
        else:
            requirements.append("- Create a PR with the changes")
        
        requirements.append("- **IMPORTANT**: After creating the PR (or if you cannot resolve the issues), mark this session as complete and report the PR URL")
        
        requirements.extend([
            "",
            f"## PR Title:",
            f"{pr_title}",
            ""
        ])
        
        if branch:
            requirements.append(f"Please proceed with fixing these issues and creating a PR to the `{branch}` branch.")
        else:
            requirements.append("Please proceed with fixing these issues and creating a PR.")
        
        prompt_parts.extend(requirements)
        
        return "\n".join(prompt_parts)


def test_api_connection(api_key: Optional[str] = None) -> bool:
    try:
        client = DevinAPIClient(api_key)
        print("Successfully initialized Devin API client")
        return True
    except ValueError as e:
        print(f"Failed to initialize client: {e}")
        return False


if __name__ == "__main__":
    import sys
    
    if test_api_connection():
        print("Devin API client is ready")
    else:
        print("Failed to initialize Devin API client")
        sys.exit(1)
